package nl.imvertor.common.file;

import java.io.File;
import java.io.IOException;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.log4j.Logger;
import org.json.JSONArray;
import org.json.JSONObject;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.dataformat.yaml.YAMLGenerator.Feature;
import com.fasterxml.jackson.dataformat.yaml.YAMLMapper;
import com.networknt.schema.InputFormat;
import com.networknt.schema.JsonSchema;
import com.networknt.schema.JsonSchemaFactory;
import com.networknt.schema.PathType;
import com.networknt.schema.SchemaLocation;
import com.networknt.schema.SchemaValidatorsConfig;
import com.networknt.schema.SpecVersion.VersionFlag;
import com.networknt.schema.ValidationMessage;

import nl.imvertor.common.Configurator;
import nl.imvertor.common.exceptions.ConfiguratorException;

public class JsonFile extends AnyFile {
	
	private static final long serialVersionUID = 5224759842363118591L;

	protected static final Logger logger = Logger.getLogger(JsonFile.class);
	
	private HashMap<String,String> parms = new HashMap<String,String>();
	
	public JsonFile(File file) throws IOException {
		super(file);
    }
	public JsonFile(String pathname) {
		super(pathname);
	}
	
	/**
	 * Determines whether deviations from the syntax of RFC7159 are permitted.
	 * 
	 * See <a href="https://www.w3.org/TR/xpath-functions-31/#func-json-to-xml">W3C spec</a>
	 * 
	 **/
	public void setLiberal(Boolean value) {
		parms.put("liberal", value.toString());
	}
	
	/**
	 * Determines the policy for handling duplicate keys in a JSON object. To determine whether keys are duplicates, they are compared using the Unicode codepoint collation, after expanding escape sequences, unless the escape option is set to true, in which case keys are compared in escaped form.
	 * 
	 * See <a href="https://www.w3.org/TR/xpath-functions-31/#func-json-to-xml">W3C spec</a>
	 * 
	 **/
	public void setDuplicates(String value) {
		parms.put("duplicates", value);
	}
	
	/**
	 * 
	 * Determines whether the generated XML tree is schema-validated.
	 * 
	 * See <a href="https://www.w3.org/TR/xpath-functions-31/#func-json-to-xml">W3C spec</a>
	 * 
	 **/
	public void setValidate(Boolean value) {
		parms.put("validate", value.toString());
	}
	
	/**
	 * Determines whether special characters are represented in the XDM output in backslash-escaped form.
	 * 
	 * See <a href="https://www.w3.org/TR/xpath-functions-31/#func-json-to-xml">W3C spec</a>
	 * 
	 **/
	public void setEscape(Boolean value) {
		parms.put("escape", value.toString());
	}
	
	/**
	 * Determines whether the json generated from XML must be indented.
	 * 
	 * See <a href="https://www.w3.org/TR/xpath-functions-31/#func-xml-to-json">W3C spec</a>
	 * 
	 **/
	public void setIndent(Boolean value) {
		parms.put("indent", value.toString());
	}
	
	/**
     * Create an XML representation of this Json file. 
     * 
     */
    public void toXml(XmlFile targetFile) throws Exception {
		XmlFile xmlFile = new XmlFile(Configurator.getInstance().getResource("static/xsl/JsonFile/jsonToXml.xml")); // dit file wordt gebruikt om het proces op te starten.
		XslFile xslFile = new XslFile(Configurator.getInstance().getResource("static/xsl/JsonFile/jsonToXml.xsl"));
		
		parms.put("jsonstring", getContent());
		
		xslFile.transform(xmlFile, targetFile, parms);
    }
    
    /**
     * Set the content to the Json serialization of the specified XML file. 
     * 
     * The XML file must adhere to XML schema <a href="https://www.w3.org/TR/xpath-functions-31/#json-to-xml-mapping">here</a>
     * 
     */
    public void fromXml(XmlFile xmlFile) throws Exception {
 		fromXml(xmlFile,false);
     }
    public void fromXml(XmlFile xmlFile, Boolean pretty) throws Exception {
 		XslFile xslFile = new XslFile(Configurator.getInstance().getResource("static/xsl/JsonFile/xmlToJson.xsl"));
 		xslFile.transform(xmlFile, this, parms);
 		if (pretty) this.prettyPrint();
     }
    
    /**
	 * Check if the Json file is well formed, i.e. can be read by a json parser. 
	 * 
	 * When errors occur, return that error message.
	 * 
	 * @return True when succeeds, no formal errors.
	 * @throws ConfiguratorException 
	 * @throws IOException 
	 */
	public boolean isWellformed() throws IOException, ConfiguratorException {
		String jsonString = getContent();
		try {
			Matcher m = Pattern.compile("^\\s*?(\\S)").matcher(jsonString);
			String firstChar = (m.find()) ? m.group(1) : ""; 
			if (firstChar.equals("{")) {
				JSONObject object = new JSONObject(jsonString); // Convert text to object
				// also check if this is an error map, generated by the JsonFile in converting from XML to Json.
				if (object.has("source") && object.get("source").equals("W3CJson"))
					throw new Exception("JSON transform error: " + object.getString("description"));
			} else if (firstChar.equals("["))
				new JSONArray(jsonString); // Convert text to array
			else
				throw new Exception("Unrecognized JSON type: \"" + firstChar + "\"");
		} catch (Exception e) {
			Configurator.getInstance().getRunner().error(logger, "Illformed JSON: \"" + e.getMessage() + "\"", null, "", "ILLFJSON");
			return false;
		}
		return true;
	}
	
	/**
	 * Validate the contents of this file. 
	 * 
	 * When errors occur, return that error message.
	 * 
	 * Try to validate against Json schema specified in content using "$schema".
	 * 
	 * See https://github.com/networknt/json-schema-validator for more info.
	 * 
	 * @return True when succeeds, no validation errors. When no schema supplied, ........? TODO
	 * @throws ConfiguratorException 
	 * @throws IOException 
	 */
	public boolean isValid(JsonFile jsonSchemaFile) throws IOException, ConfiguratorException {
		try {
			
			// This creates a schema factory that will use Draft 2012-12 as the default if $schema is not specified
			// in the schema data. If $schema is specified in the schema data then that schema dialect will be used
			// instead and this version is ignored.
			JsonSchemaFactory jsonSchemaFactory = JsonSchemaFactory.getInstance(VersionFlag.V202012, builder -> 
			    // This creates a mapping from $id which starts with https://www.example.org/ to the retrieval URI classpath:schema/
			    builder.schemaMappers(schemaMappers -> schemaMappers.mapPrefix("https://www.example.org/", "classpath:schema/"))
			);

			SchemaValidatorsConfig config = new SchemaValidatorsConfig();
			// By default JSON Path is used for reporting the instance location and evaluation path
			config.setPathType(PathType.JSON_POINTER);
			// By default the JDK regular expression implementation which is not ECMA 262 compliant is used
			// Note that setting this to true requires including the optional joni dependency
			// config.setEcma262Validator(true);

			// Due to the mapping the schema will be retrieved from the classpath at classpath:schema/example-main.json.
			// If the schema data does not specify an $id the absolute IRI of the schema location will be used as the $id.
			
			JsonSchema schema = null;
			if (jsonSchemaFile != null)
				schema = jsonSchemaFactory.getSchema(jsonSchemaFile.toURI());
			else 
				schema = jsonSchemaFactory.getSchema(SchemaLocation.of("https://www.example.org/example-main.json"), config);
			
			String input = getContent();

			Set<ValidationMessage> assertions = schema.validate(input, InputFormat.JSON, executionContext -> {
			    // By default since Draft 2019-09 the format keyword only generates annotations and not assertions
			    executionContext.getExecutionConfig().setFormatAssertionsEnabled(true);
			});
			
			// geef de eerste melding als fout af
			Iterator<ValidationMessage> it = assertions.iterator();
			
			// Toon alle fouten in het console in debug mode.
			int cnt = 0;
			while (it.hasNext()) {
				ValidationMessage next = it.next();
				Configurator.getInstance().getRunner().debug(logger, "JSONSCHEMA", "Json schema error: " + next.getMessage());
				cnt++;
			}
			if (cnt != 0)
				throw new Exception(assertions.iterator().next().getMessage() + " (first of " + cnt  + " errors)");
			
			
		} catch (Exception e) {
			Configurator.getInstance().getRunner().error(logger, "Invalid JSON: \"" + e.getMessage() + "\"", null, "", "INVJSON");
			return false;
		}
		return true;
	}
	
    /**
     * Create a Yaml representation of this Json file. 
     * 
     * @param configurator
     * @param resultYamlFile
     * @return
     * @throws Exception 
     */
    public boolean toYaml(YamlFile resultYamlFile) throws Exception {
		try {
			 // parse JSON
	        JsonNode jsonNodeTree = new ObjectMapper().readTree(getContent());
	        // save it as YAML
	        YAMLMapper m = new YAMLMapper();
	        m.disable(Feature.WRITE_DOC_START_MARKER);
	        m.enable(Feature.ALWAYS_QUOTE_NUMBERS_AS_STRINGS); // #issues/244
	        m.disable(Feature.MINIMIZE_QUOTES); // #244
	        String jsonAsYaml = m.writeValueAsString(jsonNodeTree);
	        resultYamlFile.setContent(jsonAsYaml);
        } catch (Exception e) {
			throw new Exception("Error parsing Json: " + e.getLocalizedMessage());
		}
		return true;
	}
    
    public void prettyPrint() throws IOException {
    	ObjectMapper mapper = new ObjectMapper();
        Object rawJson = mapper.readValue(getContent(), Object.class);
        String prettyJson = mapper.writerWithDefaultPrettyPrinter().writeValueAsString(rawJson);
        setContent(prettyJson);
    }
    
    /*
    static JSONObject loadJsonFromFile(File file) throws FileNotFoundException {
        Reader reader = new FileReader(file);
        return new JSONObject(new JSONTokener(reader));
    }
    */
}
